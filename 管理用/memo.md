1. 変数・命名
   1.1. 意味のない変数名（例：$a, $b, $c）を、具体的な変数名に変更する
   1.2. マジックナンバー（具体的な意味を持たない数値）を、定数または変数に置き換える
   1.3. boolean値を返す関数の名前を、is_, has_, can_ などで始める
   1.4. 複数の意味を持つ変数（例：$data）を、役割ごとに分割する
   1.5. 否定形を含む変数名（例：$isNotValid）を、肯定形（$isValid）に変更する
   1.6. 略語や短縮形を多用した変数名を、正式な単語に置き換える
   1.7. 変数名と型が一致していない場合（例：配列を $count と命名）、修正する
   1.8. ループ内で使用する変数名（例：$i, $j）を、具体的な変数名に変更する
   1.9. グローバル変数を、クラスのプロパティまたは関数の引数に置き換える
   1.10. 変数のスコープを、必要最小限の範囲に限定する

2. 関数・メソッド
   2.1. 長すぎる関数を、複数の小さな関数に分割する
   2.2. 重複したコードを、共通の関数として抽出する
   2.3. 関数の引数が多すぎる場合、オブジェクトまたは配列にまとめる
   2.4. boolean値を引数とする関数を、複数の関数に分割する
   2.5. 関数が複数の役割を持っている場合、役割ごとに分割する
   2.6. 関数内で使用されているマジックナンバーを、引数または定数に置き換える
   2.7. 関数名と処理内容が一致していない場合、修正する
   2.8. 関数の副作用（関数の外部の状態を変更する）を最小限にする
   2.9. コメントで処理内容を説明しているコードを、関数として抽出する
   2.10. ネストが深い条件分岐を、ガード句または早期returnで改善する

3. クラス・オブジェクト
   3.1. 大きすぎるクラスを、複数の小さなクラスに分割する
   3.2. クラスの責務が複数ある場合、単一責務の原則に従って分割する
   3.3. クラス間の依存関係を、インターフェースまたは抽象クラスで疎結合にする
   3.4. クラスのプロパティへの直接アクセスを、getter/setterメソッド経由にする
   3.5. クラスのコンストラクタで複雑な処理を行っている場合、ファクトリーパターンを検討する
   3.6. クラスのメソッドが多すぎる場合、関連するメソッドを別のクラスに移動する
   3.7. 親クラスのメソッドをオーバーライドする際、親クラスのメソッドを適切に呼び出す
   3.8. クラスのプロパティがpublicになっている場合、適切なアクセス修飾子（private, protected）を設定する
   3.9. クラスのメソッドがstaticになっている場合、インスタンスメソッドに変更できるか検討する
   3.10. クラスのコンストラクタで外部サービスに依存している場合、依存性注入（DI）を検討する

4. 条件分岐・ループ
   4.1. ネストが深い条件分岐を、ガード句または早期returnで改善する
   4.2. 条件分岐の条件式が複雑すぎる場合、変数または関数に抽出する
   4.3. 条件分岐の条件式が否定形になっている場合、肯定形に変更する
   4.4. 条件分岐の条件式がnull判定とempty判定を混在させている場合、統一する
   4.5. switch文を、ポリモーフィズムまたはストラテジーパターンで置き換える
   4.6. ループ内で条件分岐を行っている場合、条件分岐をループの外に出す
   4.7. ループ内で同じ計算を繰り返している場合、ループの外で計算する
   4.8. ループ内でデータベースへのアクセスを行っている場合、バルク処理を検討する
   4.9. ループ内でオブジェクトを生成している場合、オブジェクトプールを検討する
   4.10. ループ内で例外処理を行っている場合、ループの外で例外処理を行う

5. その他
   5.1. コメントが古いまたは間違っている場合、修正または削除する
   5.2. コメントでコードの説明が重複している場合、コメントを削除する
   5.3. 例外処理が適切に行われていない場合、例外処理を追加または修正する
   5.4. 例外を握りつぶしている場合、適切な例外処理を行う
   5.5. エラーメッセージが不親切な場合、具体的なエラーメッセージに変更する
   5.6. ログ出力が不足している場合、ログ出力を追加する
   5.7. ログ出力が過剰な場合、ログ出力を削減する
   5.8. テストコードがない場合、テストコードを作成する
   5.9. テストコードが不足している場合、テストコードを追加する
   5.10. テストコードが複雑すぎる場合、テストコードをリファクタリングする
   5.11. 未使用の変数、関数、クラスを削除する
   5.12. コピペされたコードを共通化する
   5.13. if-else文を三項演算子で置き換える
   5.14. 三項演算子をif-else文で置き換える（可読性のため）
   5.15. foreach文をarray_map, array_filter, array_reduceなどで置き換える
   5.16. 配列のキーを定数で管理する
   5.17. 文字列の連結をsprintfまたはテンプレートエンジンで置き換える
   5.18. 正規表現を定数で管理する
   5.19. 日付や時刻のフォーマットを定数で管理する
   5.20. 設定ファイル（.ini, .yaml, .json）を導入する
   5.21. 環境変数を利用する
   5.22. 依存関係を明示的にする（依存性注入）
   5.23. エラーハンドリングを一箇所に集約する
   5.24. ログ出力の形式を統一する
   5.25. コーディング規約に従う
   5.26. 静的解析ツールを導入する
   5.27. コードフォーマッターを導入する
   5.28. バージョン管理システム（Git）を利用する
   5.29. CI/CDパイプラインを構築する
   5.30. パフォーマンスボトルネックを特定し、改善する
   5.31. セキュリティ脆弱性を修正する
   5.32. データベースのクエリを最適化する
   5.33. キャッシュを導入する
   5.34. 非同期処理を導入する
   5.35. メモリリークを修正する
   5.36. ファイルの読み書き処理を最適化する
   5.37. ネットワーク通信を最適化する
   5.38. フロントエンドのコードをリファクタリングする
   5.39. CSSのコードをリファクタリングする
   5.40. JavaScriptのコードをリファクタリングする
   5.41. ドキュメントを整備する
   5.42. READMEを充実させる
   5.43. コントリビューションガイドを作成する
   5.44. コードレビューを導入する
   5.45. ペアプログラミングを導入する
   5.46. リファクタリングのプラクティスを学ぶ
   5.47. リファクタリングの書籍を読む
   5.48. リファクタリングのワークショップに参加する
   5.49. リファクタリングのコミュニティに参加する
   5.50. リファクタリングの成果を共有する
   5.51. レガシーコードをリファクタリングする
   5.52. 大規模なリファクタリングを行う
   5.53. リファクタリングの計画を立てる
   5.54. リファクタリングの優先順位をつける
   5.55. リファクタリングの進捗を管理する
   5.56. リファクタリングの成果を測定する
   5.57. リファクタリングのコストを見積もる
   5.58. リファクタリングのリスクを評価する
   5.59. リファクタリングの経験を振り返る
   5.60. リファクタリングのスキルを継続的に向上させる